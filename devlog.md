# Go Reader Interface Processor

## 12 Jan 2026:
   I chose a nested pattern for the project structure over a flat structure in order to separate concerns into routing and data structures. Spent quite some time deciding on what to use for a front-end, but in the end  I decided to move away from a tui application and will use the html/template from the standard library to handle a "card view" rendering for the blog posts. I put some minimal code in the main.go as well as the handlers.go and the blog.go. One of the main challenges today was that I am used to working in a flat structure. I instinctively made a duplicate main.go file in the root of the project. It took me a little time to figure out why i was getting import errors.  One other note about this project is that I will be using multiple machines to write the code. So, I will be using mainly pull and push git commands. I don't really see a need for using branches at this time but this may change.

## 13 Jan 2026
Today had some growing pains working in a nested structure versus a flat structure that many tutorials and guided projects have. I think I have overcome most of that now by organizing the project into internal/logic for the engine and internal/handlers for the web logic. The largest part of my time today was spent on the logic. I started with just one API call to Dev.to, as its API is pretty simple. In the "logic" part of the project, I defined a Source interface to keep things flexible.
As far as structs go, I created a DevTo struct and a Search method to handle the Dev.to API calls and JSON parsing. I’m currently weighing if there is a cleaner way to do this or if it’s better to have a different struct for every API call, but for now, the interface handles it well. As far as searching goes today, I just hardcoded the query "golang" in the handler to easily test the connectivity and parsing logic. All seems to work fine, though the wiring between the main package and the handlers package required some careful dependency injection to get the engine running.
I also created an index.html using the html/template package from the Go standard library for a simple UI. All rendering is done server-side, which keeps the project lightweight. I have checks in place, like template.Must and proper error wrapping, to crash the app immediately if there’s a failure. This helps save me from memory leaks—thanks to defer resp.Body.Close()—and ensures I'm not unintentionally ddosing the API with bad requests if the setup is broken.
